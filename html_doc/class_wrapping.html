<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
    <link href="pyd.css" rel="stylesheet" type="text/css">
    <title>Wrapping classes</title>
</head>

<body>
<div id="nav">
<p><big>Contents</big></p>
<a class="nav" href="index.html">Main</a><br />
<a class="nav" href="basics.html">The basics</a><br />
<a class="nav" href="celerid.html">CeleriD</a><br />
<a class="nav" href="conversion.html">Type conversion</a><br />
<a class="nav" href="func_wrapping.html">Function wrapping</a><br />
<a class="navcur" href="class_wrapping.html">Class wrapping</a><br />
<a class="nav" href="except_wrapping.html">Exception wrapping</a><br />
<a class="nav" href="dpyobject.html">DPyObject</a>
</div>

<div id="content">

<h1>Class wrapping</h1>

<p>Exposing D classes to Python is easy! The heart of Pyd's class wrapping features is the <code>wrapped_class</code> template struct:</p>

<p><code>struct wrapped_class(<span class="t_arg">T</span>, char[] <span class="t_arg">classname</span> = symbolnameof!(T));</code></p>
    <ul>
    <li><span class="t_arg">T</span> is the class being wrapped.</li>
    <li><span class="t_arg">classname</span> is the name of the class as it will appear in Python.</li>
    </ul>

<p>To expose the constructors, methods, and properties of the class, <code>wrapped_class</code> provides a series of template member functions.</p>

<dl>
<dt><code>static void def(alias <span class="t_arg">fn</span>, char[] <span class="t_arg">name</span> = symbolnameof!(fn), <span class="t_arg">fn_t</span> = typeof(&amp;fn)) ();</code></dt>
<dd>This wraps a method of the class. It functions exactly like the <code>def</code> function used to <a href="func_wrapping.html">wrap regular functions</a>, with one very important difference: There is no support for default arguments. (This is a side-effect of the fact that you cannot call an alias of a method in D, and delegates do not understand default arguments.)</dd>

<dt><code>static void prop(alias <span class="t_arg">fn</span>, char[] <span class="t_arg">name</span> = symbolnameof!(fn), bool <span class="t_arg">RO</span> = false) ();</code></dt>
<dd>This wraps a property. See the examples below for more details.
    <ul>
    <li><span class="t_arg">fn</span> is the name of the property. <code>prop</code> will automatically attempt to wrap both the "get" and "set" forms of the property, unless <span class="t_arg">RO</span> is specified.</li>
    <li><span class="t_arg">name</span> is the name of the property as it will appear in Python. As with <code>def</code>, <code>prop</code> will attempt to derive this automatically.</li>
    <li><span class="t_arg">RO</span> specifies whether this is a <i>read-only</i> property. If true, it will only wrap the "get" form of the property. If false, it will wrap both the "get" and "set" forms. (This is a little hackish, and I will probably try to make this detection more automatic in the future. It also means it cannot support a property that only has a "set" form.)</li>
    </ul>
</dd>

<dt><code>static void init(<span class="t_arg">C1</span>, <span class="t_arg">C2</span>, <span class="t_arg">C3</span>, ..., <span class="t_arg">C<i>n</i></span>) ();</code></dt>
<dd>This allows you to expose anywhere from zero to 10 of the class's constructors to Python. If the class provides a zero-argument constructor, there is no need to specify it; it is always available. Each of <span class="t_arg">C<i>n</i></span> should be a function type. Each function type should correspond to a constructor. (That is, the arguments to the function should be the same as arguments to the class constructor. The return type is ignored.) There is an additional limitation at this time: No two constructors may have the same number of arguments. Pyd will always attempt to call the first constructor with the right number of arguments. If you wish to support a constructor with default arguments, you must specify each possible constructor call as a different template argument to this function. The examples show a few uses of the <code>init</code> function.</dd>

<dt><code>static void iter(<span class="t_arg">iter_t</span>) ();</code></dt>
<dd>This allows the user to specify a different overload of opApply than the default. (The default is always the one that is lexically first.) The <span class="t_arg">iter_t</span> argument should be the type of the delegate that forms the argument to opApply. This might be e.g. <code>int delegate(inout int)</code>. Don't forget the <code>inout</code> modifiers!</dd>

<dt><code>static void alt_iter(alias <span class="t_arg">fn</span>, char[] <span class="t_arg">name</span> = symbolnameof!(fn), <span class="t_arg">iter_t</span> = <i>implementationDetail</i>) ();</code></dt>
<dd>This wraps alternate iterator methods as Python methods that return iterator objects. The wrapped methods should have a signature like that of opApply. (In other words, they should be methods intended to be used with D's ability to iterate over delgates.) The <span class="t_arg">iter_t</span> argument should be the type of the delegate argument to the method. This will usually be derived automatically.
</dd>
</dl>

<p>Once you have called all of the member functions of <code>wrapped_class</code> that you wish to, you must issue a call to <code>finalize_class</code>.</p>

<p><code>void finalize_class(<span class="t_arg">CLS</span>) (<span class="t_arg">CLS</span> <span class="arg">cls</span>);</code></p>

<p>This does some final initialization of the class and then registers it with Python. Unlike calls to <a href="func_wrapping.html"><code>def</code></a>, calls to <code>finalize_class</code> must occur <em>after</em> calling <code>module_init</code>. The <span class="arg">cls</span> function argument should be an instance of <code>wrapped_class</code>.</p>

<p>If you ever wish to check whether a given class has been wrapped, Pyd helpfully registers all wrapped classes with the <code>is_wrapped</code> template, which is just a templated <code>bool</code>:</p>

<p><code>template is_wrapped(<span class="t_arg">T</span>);</code></p>

<p>If you have a class <code>Foo</code>, you can check whether it is wrapped by simply checking whether <code>is_wrapped!(Foo)</code> is true. It is important to note that this is <em>not</em> a <code>const bool</code>, it is a <em>runtime</em> check.</p>

<h3><a class="anchor" name="opwrap">Automatic operator overloading</a></h3>

<p>Pyd will automatically wrap most of D's operator overload functions with appropriate Python operator overloads. There are some caveats:</p>

<ul>
<li>Pyd will only automatically wrap the lexically first <i>opFunc</i> defined for a given <i>opFunc</i>. <i>(In the future, I may add a mechanism allowing a user to specifiy a specific overload of an opFunc.)</i></li>
<li>The usual rules for function wrapping apply: Only an <i>opFunc</i> whose return type and arguments are <a href="conversion.html">convertable</a> may be wrapped. <i>(The current implementation is pretty dumb: If the lexically first opFunc has an unconvertable return type or argument, the operator overload will still be wrapped, but won't work.)</i></li>
</ul>

<p>At the moment, only the following operator overloads are supported:</p>

<p><code>opAdd, opSub, opMul, opDiv, opMod, opAnd, opOr, opXor, opShl, opShr, opCat, opAddAssign, opSubAssign, opMulAssign, opDivAssign, opModAssign, opAndAssign, opOrAssign, opXorAssign, opShlAssign, opShrAssign, opCatAssign, opIn_r, opCmp, opCall, opApply, opIndex, opIndexAssign, opSlice, opSliceAssign</code></p>

<p>Missing from this list are <code>opUShr</code> and <code>opUShrAssign</code>. Python does not have an unsigned right-shift operator, so these operator overloads are not supported. (You may still wrap them with a normal method using <code>wrapped_class.def</code>, of course.) Also missing from the list is <code>opApplyReverse</code>. This must be wrapped explicitly with <code>wrapped_class.alt_iter</code>.</p>

<p>Additionally, if a class provides a <code>length</code> property, Pyd will automatically make it available via Python's built-in function <code>len</code> and the special <code>__len__</code> method. You may still wrap it with <code>prop</code> or <code>def</code> if you wish it to be available as a normal property or method.</p>

<p><b>Notes on wrapped operators</b></p>

<dl>
<dt><code>opApply</code></dt> <dd>Pyd wraps D's iteration protocol with the help of Mikola Lysenko's StackThreads package.</dd>
<dt><code>opSlice, opSliceAssign</code></dt> <dd>Pyd only supports these overloads if both of their two indexes are implicitly convertable to type <code>int</code>. This is a limitation of the Python/C API. Note that this means the zero-argument form of opSlice (for allowing the "empty slice," e.g. <code>foo[]</code>) cannot be wrapped. <i>(I may work around this in the future.)</i> Because Pyd can only automatically wrap the lexically-first method in a class, it will fail to wrap opSlice and opSliceAssign if you define an empty form first.</dd>
<dt><code>opCat, opCatAssign</code></dt> <dd>Python does not have a dedicated array concatenation operator. The plus sign (<code>+</code>) is reused for this purpose. Therefore, odd behavior may result with classes that define both <code>opAdd/opAddAssign</code> and one or both of these operators. (Consider yourself warned.) However, the Python/C API considers addition and concatenation distinct operations, and so both of these sets of operator overloads are supported.</dd>
<dt><code>opIn_r</code></dt> <dd>Python expects the <code>in</code> operator to return a boolean value (it is a containment test). D convention is for <code>in</code> to search for the value in the container, and to return a pointer to the found item, or <code>null</code> if the item is not found. That said, D does not enforce any particular signature on the <code>in</code> overload, while the Python/C API does. Pyd will check the boolean result of a call to <code>opIn_r</code>, and return that value to Python.</dd>
</dl>

<h3><a class="anchor" name="examples">Examples</a></h3>

<p>Suppose we have the following simple class:</p>

<pre class="code"><span class="keyword">import</span> std.stdio;

<span class="keyword">class</span> Foo {
    <span class="keyword">int</span> m_i;

    <span class="keyword">this</span>() { m_i = <span class="number">0</span>; }
    <span class="keyword">this</span>(<span class="keyword">int</span> j) { m_i = j; }
    <span class="keyword">this</span>(<span class="keyword">int</span> j, <span class="keyword">int</span> k) { m_i = j + k; }

    <span class="keyword">int</span> i() { <span class="keyword">return</span> m_i; }
    <span class="keyword">void</span> i(<span class="keyword">int</span> j) { m_i = j; }

    <span class="keyword">void</span> foo(<span class="keyword">char</span>[] s) {
        writefln(s, m_i);
    }

    Foo opAdd(Foo rhs) {
        <span class="keyword">return new</span> Foo(m_i + rhs.m_i);
    }
}</pre>

<p>We would expose this class to Python by putting this code in our init function after the call to <code>module_init</code>:</p>

<pre class="code"><span class="comment">// Make an instance of wrapped_class</span>
wrapped_class!(Foo) f;
<span class="comment">// Wrap the "foo" method</span>
f.def!(Foo.foo);
<span class="comment">// Wrap the "i" property</span>
f.prop!(Foo.i);
<span class="comment">// Wrap the constructors.</span>
f.init!(<span class="keyword">void function</span>(<span class="keyword">int</span>), <span class="keyword">void function</span>(<span class="keyword">int</span>, <span class="keyword">int</span>));
finalize_class(f);</pre>

<p>Now we can use this type from within Python like any other type.</p>

<pre class="code">&gt;&gt;&gt; from testmodule import Foo
&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; f.i
0
&gt;&gt;&gt; f.i = 20
&gt;&gt;&gt; f.foo("Hello! i is ")
Hello! i is 20
&gt;&gt;&gt; f = Foo(10, 10)
&gt;&gt;&gt; f.i
20
&gt;&gt;&gt; g = Foo(30)
&gt;&gt;&gt; g.i
30
&gt;&gt;&gt; e = f + g
&gt;&gt;&gt; e.i
50
&gt;&gt;&gt; # We can even subclass our D type
&gt;&gt;&gt; class MyFoo(Foo):
... 	def bar(self):
... 		print "Hey, i+3 is", self.i + 3
... 
&gt;&gt;&gt; h = MyFoo(3)
&gt;&gt;&gt; h.bar()
Hey, i+3 is 6
&gt;&gt;&gt; </pre>

</div>

</body>
</html>

