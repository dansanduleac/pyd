/**
 * This module contains template for inferring the number of arguments,
 * the return type, and argument types of an arbitrary function pointer.
 * 
 * This module was automatically generated by ftype.py
 * 
 * Written by Daniel Keep.
 * Released to public domainâ€”share and enjoy (just leave my name in it,
 * pretty please).
 */
module pyd.ftype;
private:

/* *** NumberOfArgs(Tf) *** */

typedef uint Arglen0 = 0;
typedef uint Arglen1 = 1;
typedef uint Arglen2 = 2;
typedef uint Arglen3 = 3;
typedef uint Arglen4 = 4;
typedef uint Arglen5 = 5;
typedef uint Arglen6 = 6;
typedef uint Arglen7 = 7;
typedef uint Arglen8 = 8;
typedef uint Arglen9 = 9;
typedef uint Arglen10 = 10;

template
ArglenT(Tr)
{
    Arglen0
    ArglenT(Tr function() fn) { assert(false); }
}

template
ArglenT(Tr, Ta1)
{
    Arglen1
    ArglenT(Tr function(Ta1) fn) { assert(false); }
}

template
ArglenT(Tr, Ta1, Ta2)
{
    Arglen2
    ArglenT(Tr function(Ta1, Ta2) fn) { assert(false); }
}

template
ArglenT(Tr, Ta1, Ta2, Ta3)
{
    Arglen3
    ArglenT(Tr function(Ta1, Ta2, Ta3) fn) { assert(false); }
}

template
ArglenT(Tr, Ta1, Ta2, Ta3, Ta4)
{
    Arglen4
    ArglenT(Tr function(Ta1, Ta2, Ta3, Ta4) fn) { assert(false); }
}

template
ArglenT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5)
{
    Arglen5
    ArglenT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5) fn) { assert(false); }
}

template
ArglenT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6)
{
    Arglen6
    ArglenT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6) fn) { assert(false); }
}

template
ArglenT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7)
{
    Arglen7
    ArglenT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7) fn) { assert(false); }
}

template
ArglenT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8)
{
    Arglen8
    ArglenT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8) fn) { assert(false); }
}

template
ArglenT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9)
{
    Arglen9
    ArglenT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9) fn) { assert(false); }
}

template
ArglenT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9, Ta10)
{
    Arglen10
    ArglenT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9, Ta10) fn) { assert(false); }
}

template
ArglenConvT(T)
{
    const uint ArglenConvT = T.init;
}

template
NumberOfArgsT(Tf)
{
    private Tf fptr;
    alias typeof(ArglenT(fptr)) type;
}

template
NumberOfArgsSwitchT(Tf)
{
    static if( is( typeof(*Tf) == function ) )
        alias NumberOfArgsT!(Tf).type type;
    else static if( is( Tf U == delegate ) )
        alias NumberOfArgsSwitchT!(U*).type type;
}

/**
 * This template will attempt to determine the number of arguments the
 * supplied function pointer or delegate type takes.  It supports a maximum of
 * 10 arguments.
 *
 * Example:
 * ----------------------------------------
 * void fnWithThreeArgs(byte a, short b, int c) {}
 * const uint numArgs = NumberOfArgs!(typeof(&fnWithThreeArgs));
 * ----------------------------------------
 */
public
template
NumberOfArgs(Tf)
{
    const uint NumberOfArgs = ArglenConvT!(NumberOfArgsSwitchT!(Tf).type);
}

template
ArgleninoutT(Tr)
{
    Arglen0
    ArgleninoutT(Tr function() fn) { assert(false); }
}

template
ArgleninoutT(Tr, Ta1)
{
    Arglen1
    ArgleninoutT(Tr function(inout Ta1) fn) { assert(false); }
}

template
ArgleninoutT(Tr, Ta1, Ta2)
{
    Arglen2
    ArgleninoutT(Tr function(inout Ta1, inout Ta2) fn) { assert(false); }
}

template
ArgleninoutT(Tr, Ta1, Ta2, Ta3)
{
    Arglen3
    ArgleninoutT(Tr function(inout Ta1, inout Ta2, inout Ta3) fn) { assert(false); }
}

template
ArgleninoutT(Tr, Ta1, Ta2, Ta3, Ta4)
{
    Arglen4
    ArgleninoutT(Tr function(inout Ta1, inout Ta2, inout Ta3, inout Ta4) fn) { assert(false); }
}

template
ArgleninoutT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5)
{
    Arglen5
    ArgleninoutT(Tr function(inout Ta1, inout Ta2, inout Ta3, inout Ta4, inout Ta5) fn) { assert(false); }
}

template
ArgleninoutT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6)
{
    Arglen6
    ArgleninoutT(Tr function(inout Ta1, inout Ta2, inout Ta3, inout Ta4, inout Ta5, inout Ta6) fn) { assert(false); }
}

template
ArgleninoutT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7)
{
    Arglen7
    ArgleninoutT(Tr function(inout Ta1, inout Ta2, inout Ta3, inout Ta4, inout Ta5, inout Ta6, inout Ta7) fn) { assert(false); }
}

template
ArgleninoutT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8)
{
    Arglen8
    ArgleninoutT(Tr function(inout Ta1, inout Ta2, inout Ta3, inout Ta4, inout Ta5, inout Ta6, inout Ta7, inout Ta8) fn) { assert(false); }
}

template
ArgleninoutT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9)
{
    Arglen9
    ArgleninoutT(Tr function(inout Ta1, inout Ta2, inout Ta3, inout Ta4, inout Ta5, inout Ta6, inout Ta7, inout Ta8, inout Ta9) fn) { assert(false); }
}

template
ArgleninoutT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9, Ta10)
{
    Arglen10
    ArgleninoutT(Tr function(inout Ta1, inout Ta2, inout Ta3, inout Ta4, inout Ta5, inout Ta6, inout Ta7, inout Ta8, inout Ta9, inout Ta10) fn) { assert(false); }
}

template
NumberOfArgsInoutT(Tf)
{
    private Tf fptr;
    alias typeof(ArgleninoutT(fptr)) type;
}

template
NumberOfArgsSwitchInoutT(Tf)
{
    static if( is( typeof(*Tf) == function ) )
        alias NumberOfArgsInoutT!(Tf).type type;
    else static if( is( Tf U == delegate ) )
        alias NumberOfArgsSwitchInoutT!(U*).type type;
}

public
template
NumberOfArgsInout(Tf)
{
    const uint NumberOfArgsInout = ArglenConvT!(NumberOfArgsSwitchInoutT!(Tf).type);
}

template
ReturnTypeT(Tf)
{
    private Tf fptr;
    static if( is( typeof(*Tf) U == function ) )
        alias U type;
    else static if( is( Tf U == delegate ) )
        alias ReturnType!(U*) type;
    else
        static assert(false, "ReturnType argument must be function pointer"
                " or delegate.");
}

/**
 * This template will attempt to discern the return type of the supplied
 * function pointer or delegate type.  It supports callables with a maximum of
 * 10 arguments.
 *
 * Example:
 * ----------------------------------------
 * uint returnsANumber() { return 42; }
 * alias ReturnType!(typeof(&returnsANumber)) RType; // RType == uint
 * ----------------------------------------
 */
public
template
ReturnType(Tf)
{
    alias ReturnTypeT!(Tf).type ReturnType;
}

/* *** ArgType(Tf, n) *** */

template
Arg1TypeT(Tr, Ta1)
{
    Ta1 Arg1TypeT(Tr function(Ta1) fn) { assert(false); }
}

template
Arg1TypeT(Tr, Ta1, Ta2)
{
    Ta1 Arg1TypeT(Tr function(Ta1, Ta2) fn) { assert(false); }
}

template
Arg1TypeT(Tr, Ta1, Ta2, Ta3)
{
    Ta1 Arg1TypeT(Tr function(Ta1, Ta2, Ta3) fn) { assert(false); }
}

template
Arg1TypeT(Tr, Ta1, Ta2, Ta3, Ta4)
{
    Ta1 Arg1TypeT(Tr function(Ta1, Ta2, Ta3, Ta4) fn) { assert(false); }
}

template
Arg1TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5)
{
    Ta1 Arg1TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5) fn) { assert(false); }
}

template
Arg1TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6)
{
    Ta1 Arg1TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6) fn) { assert(false); }
}

template
Arg1TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7)
{
    Ta1 Arg1TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7) fn) { assert(false); }
}

template
Arg1TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8)
{
    Ta1 Arg1TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8) fn) { assert(false); }
}

template
Arg1TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9)
{
    Ta1 Arg1TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9) fn) { assert(false); }
}

template
Arg1TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9, Ta10)
{
    Ta1 Arg1TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9, Ta10) fn) { assert(false); }
}

template
Arg2TypeT(Tr, Ta1, Ta2)
{
    Ta2 Arg2TypeT(Tr function(Ta1, Ta2) fn) { assert(false); }
}

template
Arg2TypeT(Tr, Ta1, Ta2, Ta3)
{
    Ta2 Arg2TypeT(Tr function(Ta1, Ta2, Ta3) fn) { assert(false); }
}

template
Arg2TypeT(Tr, Ta1, Ta2, Ta3, Ta4)
{
    Ta2 Arg2TypeT(Tr function(Ta1, Ta2, Ta3, Ta4) fn) { assert(false); }
}

template
Arg2TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5)
{
    Ta2 Arg2TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5) fn) { assert(false); }
}

template
Arg2TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6)
{
    Ta2 Arg2TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6) fn) { assert(false); }
}

template
Arg2TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7)
{
    Ta2 Arg2TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7) fn) { assert(false); }
}

template
Arg2TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8)
{
    Ta2 Arg2TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8) fn) { assert(false); }
}

template
Arg2TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9)
{
    Ta2 Arg2TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9) fn) { assert(false); }
}

template
Arg2TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9, Ta10)
{
    Ta2 Arg2TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9, Ta10) fn) { assert(false); }
}

template
Arg3TypeT(Tr, Ta1, Ta2, Ta3)
{
    Ta3 Arg3TypeT(Tr function(Ta1, Ta2, Ta3) fn) { assert(false); }
}

template
Arg3TypeT(Tr, Ta1, Ta2, Ta3, Ta4)
{
    Ta3 Arg3TypeT(Tr function(Ta1, Ta2, Ta3, Ta4) fn) { assert(false); }
}

template
Arg3TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5)
{
    Ta3 Arg3TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5) fn) { assert(false); }
}

template
Arg3TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6)
{
    Ta3 Arg3TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6) fn) { assert(false); }
}

template
Arg3TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7)
{
    Ta3 Arg3TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7) fn) { assert(false); }
}

template
Arg3TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8)
{
    Ta3 Arg3TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8) fn) { assert(false); }
}

template
Arg3TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9)
{
    Ta3 Arg3TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9) fn) { assert(false); }
}

template
Arg3TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9, Ta10)
{
    Ta3 Arg3TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9, Ta10) fn) { assert(false); }
}

template
Arg4TypeT(Tr, Ta1, Ta2, Ta3, Ta4)
{
    Ta4 Arg4TypeT(Tr function(Ta1, Ta2, Ta3, Ta4) fn) { assert(false); }
}

template
Arg4TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5)
{
    Ta4 Arg4TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5) fn) { assert(false); }
}

template
Arg4TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6)
{
    Ta4 Arg4TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6) fn) { assert(false); }
}

template
Arg4TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7)
{
    Ta4 Arg4TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7) fn) { assert(false); }
}

template
Arg4TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8)
{
    Ta4 Arg4TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8) fn) { assert(false); }
}

template
Arg4TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9)
{
    Ta4 Arg4TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9) fn) { assert(false); }
}

template
Arg4TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9, Ta10)
{
    Ta4 Arg4TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9, Ta10) fn) { assert(false); }
}

template
Arg5TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5)
{
    Ta5 Arg5TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5) fn) { assert(false); }
}

template
Arg5TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6)
{
    Ta5 Arg5TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6) fn) { assert(false); }
}

template
Arg5TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7)
{
    Ta5 Arg5TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7) fn) { assert(false); }
}

template
Arg5TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8)
{
    Ta5 Arg5TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8) fn) { assert(false); }
}

template
Arg5TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9)
{
    Ta5 Arg5TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9) fn) { assert(false); }
}

template
Arg5TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9, Ta10)
{
    Ta5 Arg5TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9, Ta10) fn) { assert(false); }
}

template
Arg6TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6)
{
    Ta6 Arg6TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6) fn) { assert(false); }
}

template
Arg6TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7)
{
    Ta6 Arg6TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7) fn) { assert(false); }
}

template
Arg6TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8)
{
    Ta6 Arg6TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8) fn) { assert(false); }
}

template
Arg6TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9)
{
    Ta6 Arg6TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9) fn) { assert(false); }
}

template
Arg6TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9, Ta10)
{
    Ta6 Arg6TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9, Ta10) fn) { assert(false); }
}

template
Arg7TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7)
{
    Ta7 Arg7TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7) fn) { assert(false); }
}

template
Arg7TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8)
{
    Ta7 Arg7TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8) fn) { assert(false); }
}

template
Arg7TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9)
{
    Ta7 Arg7TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9) fn) { assert(false); }
}

template
Arg7TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9, Ta10)
{
    Ta7 Arg7TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9, Ta10) fn) { assert(false); }
}

template
Arg8TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8)
{
    Ta8 Arg8TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8) fn) { assert(false); }
}

template
Arg8TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9)
{
    Ta8 Arg8TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9) fn) { assert(false); }
}

template
Arg8TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9, Ta10)
{
    Ta8 Arg8TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9, Ta10) fn) { assert(false); }
}

template
Arg9TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9)
{
    Ta9 Arg9TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9) fn) { assert(false); }
}

template
Arg9TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9, Ta10)
{
    Ta9 Arg9TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9, Ta10) fn) { assert(false); }
}

template
Arg10TypeT(Tr, Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9, Ta10)
{
    Ta10 Arg10TypeT(Tr function(Ta1, Ta2, Ta3, Ta4, Ta5, Ta6, Ta7, Ta8, Ta9, Ta10) fn) { assert(false); }
}

template
ArgTypeT(Tf, uint n)
{
    private Tf fptr;
    static if( n == 1 )
        alias typeof(Arg1TypeT(fptr)) type;
    else static if( n == 2 )
        alias typeof(Arg2TypeT(fptr)) type;
    else static if( n == 3 )
        alias typeof(Arg3TypeT(fptr)) type;
    else static if( n == 4 )
        alias typeof(Arg4TypeT(fptr)) type;
    else static if( n == 5 )
        alias typeof(Arg5TypeT(fptr)) type;
    else static if( n == 6 )
        alias typeof(Arg6TypeT(fptr)) type;
    else static if( n == 7 )
        alias typeof(Arg7TypeT(fptr)) type;
    else static if( n == 8 )
        alias typeof(Arg8TypeT(fptr)) type;
    else static if( n == 9 )
        alias typeof(Arg9TypeT(fptr)) type;
    else static if( n == 10 )
        alias typeof(Arg10TypeT(fptr)) type;
    else
        static assert(false,
                "Maximum of 10 arguments supported.");
}

template
ArgTypeSwitchT(Tf, uint n)
{
    static if( is( typeof(*Tf) == function ) )
        alias ArgTypeT!(Tf, n).type type;
    else static if( is( Tf U == delegate ) )
        alias ArgTypeSwitchT!(U*, n).type type;
    else
        static assert(false, "ArgType argument must be a function pointer"
                " or a delegate.");
}

/**
 * This template will attempt to extract the type of the nth argument of the
 * given function pointer or delegate type.  It supports callables with up to
 * 10 arguments.
 *
 * Example:
 * ----------------------------------------
 * void intShortBool(int a, short b, bool c) {}
 * alias ArgType!(typeof(&intShortBool), 2) TArg2; // TArg2 == short
 * ----------------------------------------
 */
public
template
ArgType(Tf, uint n)
{
    alias ArgTypeSwitchT!(Tf, n).type ArgType;
}

/* *** Unit tests *** */

unittest
{
    alias int function()                                    fn_0args;
    alias byte[] function(char)                             fn_1arg;
    alias float[dchar] function(int, int[])                 fn_2args;
    alias void function(int, float[char[]], ifloat[byte])   fn_3args;

    alias int[] delegate()                                  dg_0args;
    alias real delegate(uint[])                             dg_1arg;
    alias void delegate(char[][char[]], bool[short])        dg_2args;
    alias dchar[wchar] delegate(byte, short, int)           dg_3args;

    // ** Test NumberOfArgs(Tf) ** //

    static assert( NumberOfArgs!(fn_0args) == 0 );
    static assert( NumberOfArgs!(fn_1arg) == 1 );
    static assert( NumberOfArgs!(fn_2args) == 2 );
    static assert( NumberOfArgs!(fn_3args) == 3 );
    static assert( NumberOfArgs!(dg_0args) == 0 );
    static assert( NumberOfArgs!(dg_1arg) == 1 );
    static assert( NumberOfArgs!(dg_2args) == 2 );
    static assert( NumberOfArgs!(dg_3args) == 3 );

    // ** Test ReturnType(Tf) ** //

    static assert( is( ReturnType!(fn_0args) == int ) );
    static assert( is( ReturnType!(fn_1arg) == byte[] ) );
    static assert( is( ReturnType!(fn_2args) == float[dchar] ) );
    static assert( is( ReturnType!(fn_3args) == void ) );
    static assert( is( ReturnType!(dg_0args) == int[] ) );
    static assert( is( ReturnType!(dg_1arg) == real ) );
    static assert( is( ReturnType!(dg_2args) == void ) );
    static assert( is( ReturnType!(dg_3args) == dchar[wchar] ) );

    // ** Test ArgType(Tf, n) ** //

    static assert( is( ArgType!(fn_1arg, 1) == char ) );
    static assert( is( ArgType!(fn_2args, 2) == int[] ) );
    static assert( is( ArgType!(fn_3args, 3) == ifloat[byte] ) );
    static assert( is( ArgType!(dg_2args, 1) == char[][char[]] ) );
    static assert( is( ArgType!(dg_3args, 1) == byte ) );
    static assert( is( ArgType!(dg_3args, 2) == short ) );

    pragma(msg, "ftype: passed static unit tests.");
}

